{"pages":[],"posts":[{"title":"【音视频开发】 视频封装与编码","text":"我们在计算机中所看到的视频，其格式（扩展名）有.mp4、.avi、.flv等，这些所代表的含义，其实是视频的封装格式。 一个视频文件由其中的视频流（也就是一系列图像）、音频流、字幕、媒资信息等组成，封装格式指的就是如何将这些东西打包起来。 由于封装格式只是表面了如何打包视频，所以只要封装格式支持对应的视频流和音频流，封装格式之间的转换其实是很快的 而对于视频流或者音频流来说，如何对他们进行编码被称作视频编码格式或音频编码格式（codec）。生成对应的流或者从对应的流中获取视频来播放，分别称为编码（encode）和解码（decode），而不同编码格式之间的互相转换称为转码（transcode）。 常见的视频编码有：","link":"/2022/05/13/codec/"},{"title":"【环境配置】 Centos7 安装 Nginx","text":"Nginx简介 Nginx是一个高性能的HTTP和反向代理web服务器，具有占有内存少，并发能力强等优点 一. 安装所需环境1. gcc安装 安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境1yum install gcc-c++ 2. PCRE pcre-devel 安装 nginx 的 http 模块使用 PCRE 来解析正则表达式1yum install -y pcre pcre-devel 3. zlib 安装 nginx 使用 zlib 对 http 包的内容进行 gzip1yum install -y zlib zlib-devel 4. OpenSSL 安装 nginx 支持 https 协议1yum install -y openssl openssl-devel 二. 下载、解压、配置、编译、安装源码包1. 使用wget下载 这里下载的是1.12.0版本的nginx1wget -c https://nginx.org/download/nginx-1.12.0.tar.gz -若没有安装wget，则使用以下命令安装wget1yum install wget 2. 解压 直接解压1tar -zxvf nginx-1.12.0.tar.gz 然后移动到解压完后的目录中1cd nginx-1.12.0 3. 配置 使用默认配置1./configure 4. 编译和安装 执行以下命令1make 1make install 5. 查看安装位置 执行以下命令查看nginx安装位置，一般位于/usr/local/nginx1whereis nginx 三. 启动、停止、重启、开机自启动1. 启动、停止、重启Nginx 移动至nginx目录1cd /usr/local/nginx/sbin/ 启动1./nginx 退出（待nginx进程处理任务完毕）1./nginx -s quit 强制退出1./nginx -s stop 重启1./nginx -s reload 2. 开机自启动 在rc.local增加启动代码1vi /etc/rc.local 增加一行：1/usr/local/nginx/sbin/nginx 设置执行权限1chmod 755 rc.local","link":"/2022/05/11/nginx-install/"},{"title":"【数据结构与算法】 快速幂算法","text":"计算x的n次方是数学上基础的运算之一。在计算机中，要完成同样的计算，如果采用符合常识的循环相乘的方式，则算法的时间复杂度为O(n)。除此之外，还有一种巧妙利用二进制特点的幂算法 —— 快速幂算法，其时间复杂度仅为O(logn)。通过快速幂算法可以领略算法之美~ 代码首先先看快速幂算法的代码： 123456789101112class Solution { public double myPow(double x, int n) { double ans = 1.0; for(int i = n; i != 0; i /= 2){ if(i % 2 != 0){ ans *= x; } x *= x; } return n &lt; 0 ? 1 / ans : ans; }} 快速幂算法的代码逻辑比较简单，大体的思路是：我们以求 x 的 n 次方为例，将 n 不断向右移位（除以2）直到 n 为0，每次移位时若 n 末位为1（即对2取模为0），则 x 乘进结果 ans 中，同时每次移位时，令 x 为 x 的平方，最终结果考虑 n 的正负性即可。从算法的代码中可以清楚地看出，其时间复杂度为 O(logn) 。 原理同样我们以求 x 的 n 次方为例，我们把 n 写成二进制的形式，记作： x^{n}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}由于： [b_{n}b_{n-1}...b_{2}b_{1}]=[b_{n}000...]+[b_{n-1}000...]+[b_{2}0]+[b_{1}]那么原式可以改写为： x^{n}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}=x^{[b_{n}b_{n-1}...b_{2}b_{1}]}=x^{[b_{n}000...]}x^{[b_{n-1}000...]}x^{[b_{2}0]}x^{[b_{1}]}即 x 的 n 次方等于 x 与 [n 各二进制位构成的数字次方]的乘积，而其中： x^{[b_{i}000...]}=x^{[b_{i-1}000...]}x^{[b_{i-1}000...]} \\quad 例如: x^{8}=x^{4}x^{4}由此，再看快速幂的计算计算流程，其中就利用了上述的特性，将 n 分别计算每一位对应的幂，若当前位为1则乘如结果，若当前位为0，则 x ^ bi 为1，结果不变，同时利用这一位的幂来计算下一位的幂。 快速幂算法利用了指数幂和二进制的特点，大大降低了运算的复杂度，是一种非常巧妙的算法。","link":"/2022/05/12/fastpower/"},{"title":"【Java】 线程池基本概念","text":"Java语言虽然内置了多线程支持，可以显式的创建线程并启动运行。但是，创建新的线程需要消耗操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。 为解决这些问题，Java标准库中提供了线程池（Thread Pool），以实现线程的复用。用一句话概括线程池的功能就是：线程池通过内部维护若干个线程用于接收小任务并进行处理。 阿里巴巴开发规约中强制规定，线程资源必须通过线程池提供，不允许在应用中自行显式创建线程，由此可见线程池在实际开发中的重要性。 线程池的创建Java标准库中采用 ExecutorService 接口来表示线程池，线程池的创建有多种方式，其中最简单的一种是通过 Executors 类中提供的静态方法来创建： 12345678// 创建一个固定大小的线程池:ExecutorService es = Executors.newFixedThreadPool(5);// 创建一个线程数根据任务动态调整的线程池:ExecutorService es = Executors.newCachedThreadPool();// 创建一个仅单线程执行的线程池:ExecutorService es = Executors.newSingleThreadExecutor(); 如果需要自己定制化线程池，则需要使用 new ThreadPoolExecutor() 的方式，其实如果看上述三个静态方法的源码，其中也都使用了 new ThreadPoolExecutor() 的方式：1234// 固定大小的线程池:public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} 我们看 ThreadPoolExecutor 类的构造方法，其中最基础的是：1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 方法有7个参数，这七个参数就是所谓的线程池七大参数，其具体含义如下： 参数 名称 int corePoolSize 核心线程数 int maximumPoolSize 最大线程数 long keepAliveTime 存活时间 TimeUnit unit 时间单位 BlockingQueue&lt;Runnable&gt; workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 拒绝策略 线程池的使用线程池的基本使用思想就是先创建线程池，然后向线程池中提交任务，任务需要实现 Runnable 接口 1234567// 创建固定大小的线程池:ExecutorService executor = Executors.newFixedThreadPool(3);// 提交任务:executor.submit(task1);executor.submit(task2);executor.submit(task3);executor.submit(task4); 下面是一个使用线程池的Demo 12345678910111213141516171819202122232425262728293031import java.util.concurrent.*;public class Main { public static void main(String[] args) { // 创建一个固定大小的线程池: ExecutorService es = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 6; i++) { es.submit(new Task(&quot;&quot; + i)); } // 关闭线程池: es.shutdown(); }}class Task implements Runnable { private final String name; public Task(String name) { this.name = name; } @Override public void run() { System.out.println(&quot;start task &quot; + name); try { Thread.sleep(1000); } catch (InterruptedException e) { } System.out.println(&quot;end task &quot; + name); }}","link":"/2022/05/12/threadpool/"},{"title":"【Java】 手撕 HashMap 源码","text":"HashMap是Java中最常用的集合之一。作为一名Java程序员，对于HashMap的理解不应仅仅限于使用，深入其源码了解其设计原理，能够加深对Java语言的认识。此外，HashMap的原理也是当前技术面试常考的基础问题之一。本文将直接手撕HashMap源码，介绍HashMap的设计原理。","link":"/2022/05/14/hashmap/"}],"tags":[{"name":"视频编码","slug":"视频编码","link":"/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"手撕源码","slug":"手撕源码","link":"/tags/%E6%89%8B%E6%92%95%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"音视频开发","slug":"音视频开发","link":"/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java开发","slug":"Java开发","link":"/categories/Java%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}